<link rel="import" href="../polymer/lib/utils/async.html">
<link rel="import" href="../polymer/lib/utils/render-status.html">
<script>
  /**
   * Mixin for methods that use Polymer.Async modules by calling their `run`
   * method immediately and returning the module so that `cancel` can be called.
   *
   * All functions return an `AsyncModule` with the `cancel` method bound to the
   * handle returned from the `run` method.
   */
  AsyncMixin = function(superClass) {
    return class extends superClass {
      /**
       * Add a cancelable timeout. A bit more complex than handling natively,
       * but included for completeness.
       * @return {Function} The AsyncInterface's cancel function bound to the correct handle.
       */
      _timeout(fn, delay) {
        let async = delay === undefined
          ? Polymer.Async.timeout
          : Polymer.Async.timeout.after(delay);
        return async.cancel.bind(async.run(fn));
      }
      /**
       * Run a function at `requestAnimationFrame` timing (before the next paint).
       * @return {Function} The AsyncInterface's cancel function bound to the correct handle.
       */
      _animationFrameBefore(fn) {
        return Polymer.Async.animationFrame.cancel.bind(Polymer.Async.animationFrame.run(fn));
      }
      /**
       * Run a function at `requestAnimationFrame` timing (after the next paint).
       * @return {Function} Cancels the animation frame and subsequent timeout.
       */
      _animationFrameAfter(fn) {
        var timeoutHandle;
        let renderHandle = Polymer.Async.animationFrame.run(function() {
          timeoutHandle = Polymer.Async.timeout.run(fn);
        });
        return function() {
          Polymer.Async.animationFrame.cancel(renderHandle);
          timeoutHandle && Polymer.Async.timeout.cancel(timeoutHandle);
        };
      }
      /**
       * Run a function before the next paint using Polymer.RenderStatus (not cancelable).
       */
      _beforeNextRender(context, callback, args) {
        return Polymer.RenderStatus.beforeNextRender(context, callback, args);
      }
      /**
       * Run a function after the next paint using Polymer.RenderStatus (not cancelable).
       */
      _afterNextRender(context, callback, args) {
        return Polymer.RenderStatus.afterNextRender(context, callback, args);
      }
      /**
       * Run a function at `requestIdleCallback` timing, or
       * falls back to settimeout 16ms if not supported.
       * @return {Function} The AsyncInterface's cancel function bound to the correct handle.
       */
      _idlePeriod(fn) {
        return Polymer.Async.idlePeriod.cancel.bind(Polymer.Async.idlePeriod.run(fn));
      }
      /**
       * Run a function at microtask timing (before the next task).
       * @return {Function} The AsyncInterface's cancel function bound to the correct handle.
       */
      _microtask(fn) {
        return Polymer.Async.microtask.cancel.bind(Polymer.Async.microtask.run(fn));
      }
    }
  }
</script>